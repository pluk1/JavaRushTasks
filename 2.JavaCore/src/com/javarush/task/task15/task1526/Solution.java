package com.javarush.task.task15.task1526;

/* 
Дебаг, дебаг, и еще раз дебаг
Ключевой вопрос этой задачи: метод initialize() в конструкторе класса А вызывается как "initialize() класса А" или "initialize() класса В"? Для ответа надо знать следующее:

Порядок обработки кода:
1) Компилятор преобразует джава-код в байт-код (программа еще не выполняется)
2) Джава-машина выполняет байт-код (собственно выполнение программы)

Порядок инициализации классов и новых объектов:
1) Статические элементы
2) Нестатические переменные родителя
3) Конструктор родителя
4) Нестатич-ие переменные наследника
5) Конструктор наследника

В объекте класса В создается 2 переменных f1.

а) Ситуация до исправления модификатора.
При вызове new B(6) сначала происходит вызов конструктора класса А, а переменная f1 в коде класса В еще не инициализировалась и равна 0. В конструкторе класса А происходит вызов метода initialize(). Поскольку этот метод может быть переопределен в классах-наследниках, то компилятор не привязывает вызов этого метода к "initialize() класса А", а отдает этот вопрос на решение джава-машины. Джава-машина видит, что метод вызван из "объекта класса В" (потому как new B(6)), и соответственно вызывает "initialize() класса В". Однако переменная f1 в коде класса В еще не успела инициализоваться (см. порядок инициализации), поэтому выводится 0.

б) Ситуация после исправления модификатора.
Все то же самое, но теперь компилятор считает, что приватный метод "initialize() класса А" переопределяться не будет. Поэтому он жестко привязывает вызов метода initialize() в конструкторе А к "initialize() класса А" еще ДО выполнения программы. И джава-машине ничего не остается как вызывать там метод initialize() именно класса А, а не класса В.

*/

public class Solution {
    public static void main(String[] args) {
        new B(6);
    }

    public static class A {
        private int f1 = 7;

        public A(int f1) {
            this.f1 = f1;
            initialize();
        }

        private void initialize() {
            System.out.println(f1);
        }
    }

    public static class B extends A {
        protected int f1 = 3;

        public B(int f1) {
            super(f1);
            this.f1 += f1;
            initialize();
        }

        protected void initialize() {
            System.out.println(f1);
        }
    }
}
